# 2019javaScript常见设计模式最新总结大全

对于每一种设计模式，我们都应要搞清楚一下4点方面的内容，才能对设计模式每个模式有个总体认识
> 1、它的定义  
> 2、它的出现解决了什么问题  
> 3、怎么用，应用场景  
> 4、优缺点或者局限性

## 1. 单例模式  

**定义：** 单例单例，单个实例，顾名思义就是创建单个类的实例，并且只提供一个全局接口来访问这个实例   

把描述同一事物（同一个对象）的属性和方法放在一个内存空间下，起到了分组的作用，这样不同事物之间的属性即使属性名相同，相互也不会冲突。这种分组编写代码的模式叫做“单例模式”。

**使用场景：**
  + 对于某些场景来说，在全局下，我们只需要一个对象来完成我们任务
  + 例如： 登录弹窗（无论点击多少次都是弹出一个对话框）、 常见的浏览器window对象等  

**优缺点：**   

优点：   
  + 提供了对唯一实例的受控访问。 
  + 避免对共享资源的多重占用
  + 保持全局命名空间的整洁
  + 优化代码结构：相关的方法和属性集中在一个地方，且只会实例化一次。简化了代码的调试和维护
  + 划分命名空间，减少全局变量，组织代码为一体，便于阅读维护
  + 防止其它对象对单例对象的实例化，确保所有的对象都访问一个实例 
  + 由于在内存只存在一个对象，节省了系统资源，当调用的对象需要频繁的创建和销毁的时候，提高系统的性能


缺点：  

+ 不适用于变化的对象当中，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 
+  单例类的职责过重，在一定程度上违背了“单一职责原则”
+  滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。 
+ 可能导致模块间的强耦合，从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。

**解决的问题**  

一个全局使用的类频繁的创建与销毁。对象创建的问题

**何时使用**  

想控制实例数目，节省系统资源的时候。

**如何解决**  

判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**代码实现单例模式**

+ 简单的单例模式实现：

> ```javascript
> const SingleTon = function (username, password) {
>   this.username = username
>   this.password = password
>   this.instance = null
> }
> 
> SingleTon.prototype.getUsername = function () {
>   alert(this.username)
> }
> 
> SingleTon.getInstance = function (username) {
>   if (!this.instance) {
>     this.instance = new SingleTon(username)
>   }
>   return this.instance
> }
> 
> const user1 = SingleTon.getInstance('zhangsan')
> const user2 = SingleTon.getInstance('lisi')
> 
> console.log( user1 === user2 )
> ```

以上代码是实现了一个标准的代理模式，但是这种方式创建的单例我们并不能向其他对象一样使用new关键字来创建一个实例，只能通过调用构造函数·`ingleTon.getInstance方法`来创建单例。增加了这个SingleTon类的不透明性，当我们调用SingleTon的时候必须知道，这是一个单例类。所以我们要针对以上代码进行升级，实现一个“透明”的单例类，使的用户能够通过`new XXX`的方式来创建类。

```

```



+ 代理实现单例模式
+ 惰性单例