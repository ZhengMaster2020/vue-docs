# Vue框架知识

## 1. MVVM的理解？以及它的优缺点？
::: warning

 MVVM模式即Model-View-ViewModel,前端开发的一种架构模式，常见的MVVM模式框架有Vue、Angular等 
  
 Model层： 代表模型、数据，可以在这一层定义数据的修改以及操作相关的逻辑业务   
 
 View层：  代表视图、模板，动态模板，定义结构，页面布局等，负责将数据模型转化为UI展现出来  
 
 ViewModel层： 连接View层与Model层的存在，View层与Model层没有直接的联系，都是通过ViewModel层进行交互，通过数据双向绑定保证视图和数据的一致性，这中一致性的工作是自动的。开发者只需要关注自己的业务逻辑便可，无需关心如何手动操作DOM。 

:::
 

![1566834193630](https://user-gold-cdn.xitu.io/2018/6/24/16430751f343e886?imageslim)

#### 优点：  
  1. 视图和模型分离，降低代码耦合，提交视图或逻辑的可重用性
  2. 提高可测试性，便于测试
  3. 不用操作DOM自动更新DOM
#### 缺点：  
  1. 难debug,Bug代码难以被调试
  2. 长期持有不释放内存，占内存
  3. VuewModel的构建和维护的成本

## 2. Vue生命周期的理解
new Vue实例的时候，vue会执行一个完整的生命周期，就是开始创建，初始化数据，编译模板，挂在DOM和渲染DOM，更新DOM渲染DOM，卸载等的一系列的过程。  （组件创建阶段--> 组件运行阶段--> 组件销毁阶段）
>
beforeCreate:   组件实例被创建之初，组件的属性生效之前    

create:  组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用，操作methods和data数据的最早阶段。 

beforeMount:  在挂载开始之前被调用：相关的 render 函数首次被调用 这里涉及虚拟DOM  

Mount:  el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 最早操作真实DOM的钩子，组件创建阶段完成  

beforeUpdate: 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前     

Update:  涉及VDOM re-render diff patch 组件数据更新之后  

beforeDestory:  组件销毁前调用  

Destoryed: 组件销毁后调用

keep-alive属性：
Actived:
deadctivated:

#### 生命周期示意图：
  ![shiyitu](https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/d1279e6d6327d23f2e97bb0bf4950b47.png)  

**官方实例的异步请求是在mounted生命周期中调用的，而实际上也可以在created生命周期中调用。**

## 3. Vue组件间的通信


## 4. Compouted 和 Watch 的区别   
1. Computed是一个惰性求值的观察者，具有缓存属性的，是计算一个新属性，而Watch则没有，相当于一个监听变动的窃听器
2.  computed计算一个新属性并将其挂在到vue的实例中去，而watch则是监听一个vue实例中已经存在并且已经挂在Vue实例的属性，一旦数据有变化就会调用回调函数。

## 5. Vue实现双向绑定的原理
  + 实现双向绑定的方法：   
    1. KnockoutJS基于**观察者模式**的双向绑定
    2. Ember基于**数据模型**的双向绑定
    3. Angular基于**脏检查**的双向绑定
    4. Vue基于**数据劫持**的双向绑定


+ 数据劫持的理解
  > 数据劫持比较好理解,通常我们利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作
  >
  >   1.  它优势是？

## 6. Vue的响应式系统的理解

## 7. Vue的变化侦测原理

## 8. Vue/React中的所要求的key有什么用 ?
+ 在Vue中进行列表渲染或者触发相同元素名等的时候，加上一个key属性是为了给Vue提供一个提示，以便它能跟踪每个节点的身份，从而更好地重用和重新排序现有元素，是Vue识别节点的一个通用机制。
+ key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。
+ 为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速
> vue和react都实现了一套虚拟DOM，使我们可以不直接操作DOM元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其高效的Diff算法.key就是为了高笑地更新虚拟DOM

## 9. 虚拟DOM
操作真实的DOM的代价是十分昂贵的，所以采用虚拟DOM来代替真实DOM的操作，以便提高性能。**所谓的虚拟DOM就是在内存中使用js对象的形式来保存真实DOM节点树被渲染之前的所包含的所有信息，并通过js操作进行维护，是真实DOM的一个简单映射。**   
通过虚拟DOM哪里发生了改变就渲染哪里，通过比较新旧虚拟DOM树就可以找出哪里相同和不同，相同的地方就复用真实DOM结点，不同的地方就对真实的DOM结点删除，增加、移动等操作，大大提升了效率。  

+ 虚拟DOM的diff算法
  
    前提：   
     i. diff只发生在同级dom结点中    
   
   两个假设：  
      1.  两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构  
      2.  同一层级的一组节点，他们可以通过唯一的id进行区分  
   基于这样的假设使得diff算法的时间复杂从从O(n^3)降到了O(n)  

   实现过程：  
   1. patch(container, vnode) 初次渲染，讲VDOM渲染成真实的DOM然后插入到容器里面  
   2. patch(vnode, newVnode) 再次渲染的时候， 将新的vnode和旧的vnode进行对象，得出差异再将其应用到真实DOM上去。

如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。

如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。

